From 6808e86d32646010efdd16f743d59b01a1d568f2 Mon Sep 17 00:00:00 2001
From: Sangdol Kim <doliyu@marusys.com>
Date: Sun, 3 Feb 2013 15:51:55 +0900
Subject: [PATCH 2/2] Enable Debugging

---
 src/shared/log.c   |    5 ++++-
 src/udev/udevadm.c |   14 ++++++++++++++
 src/udev/udevd.c   |   40 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 58 insertions(+), 1 deletions(-)

diff --git a/src/shared/log.c b/src/shared/log.c
index 6357868..224d408 100644
--- a/src/shared/log.c
+++ b/src/shared/log.c
@@ -38,7 +38,8 @@
 #define SNDBUF_SIZE (8*1024*1024)
 
 static LogTarget log_target = LOG_TARGET_CONSOLE;
-static int log_max_level = LOG_INFO;
+//static int log_max_level = LOG_INFO;
+static int log_max_level = LOG_DEBUG;
 static int log_facility = LOG_DAEMON;
 
 static int console_fd = STDERR_FILENO;
@@ -489,6 +490,8 @@ static int log_dispatch(
 
         int r = 0;
 
+	printf("%d, %s,%s, %s\n",line, func, file,  buffer );
+	return 0;
         if (log_target == LOG_TARGET_NULL)
                 return 0;
 
diff --git a/src/udev/udevadm.c b/src/udev/udevadm.c
index 818edee..68bbdde 100644
--- a/src/udev/udevadm.c
+++ b/src/udev/udevadm.c
@@ -95,15 +95,21 @@ int main(int argc, char *argv[])
         unsigned int i;
         int rc = 1;
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         udev = udev_new();
         if (udev == NULL)
                 goto out;
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         log_parse_environment();
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         log_open();
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         udev_set_log_fn(udev, udev_main_log);
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         label_init("/dev");
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         for (;;) {
                 int option;
 
@@ -128,13 +134,17 @@ int main(int argc, char *argv[])
         }
         command = argv[optind];
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         if (command != NULL)
                 for (i = 0; i < ELEMENTSOF(udevadm_cmds); i++) {
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
                         if (strcmp(udevadm_cmds[i]->name, command) == 0) {
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
                                 argc -= optind;
                                 argv += optind;
                                 optind = 0;
                                 rc = run_command(udev, udevadm_cmds[i], argc, argv);
+printf("doliyu: %d, %s, %s,rc= %d\n", __LINE__, __FUNCTION__, __FILE__, rc );
                                 goto out;
                         }
                 }
@@ -143,8 +153,12 @@ int main(int argc, char *argv[])
         adm_help(udev, argc, argv);
         rc = 2;
 out:
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         label_finish();
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         udev_unref(udev);
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         log_close();
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         return rc;
 }
diff --git a/src/udev/udevd.c b/src/udev/udevd.c
index 9bbc8ec..7db83bf 100644
--- a/src/udev/udevd.c
+++ b/src/udev/udevd.c
@@ -1083,16 +1083,24 @@ int main(int argc, char *argv[])
         struct udev_ctrl_connection *ctrl_conn = NULL;
         int rc = 1;
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         udev = udev_new();
         if (udev == NULL)
                 goto exit;
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         log_set_target(LOG_TARGET_AUTO);
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         log_parse_environment();
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         log_open();
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         udev_set_log_fn(udev, udev_main_log);
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         log_debug("version %s\n", VERSION);
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         label_init("/dev");
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
 
         for (;;) {
                 int option;
@@ -1148,27 +1156,35 @@ int main(int argc, char *argv[])
                 }
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         kernel_cmdline_options(udev);
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         if (getuid() != 0) {
                 fprintf(stderr, "root privileges required\n");
                 log_error("root privileges required\n");
                 goto exit;
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         /* set umask before creating any file/directory */
         chdir("/");
         umask(022);
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         mkdir("/run/udev", 0755);
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         dev_setup(NULL);
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         static_dev_create_from_modules(udev);
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         /* before opening new files, make sure std{in,out,err} fds are in a sane state */
         if (daemonize) {
                 int fd;
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
                 fd = open("/dev/null", O_RDWR);
                 if (fd >= 0) {
                         if (write(STDOUT_FILENO, 0, 0) < 0)
@@ -1181,10 +1197,13 @@ int main(int argc, char *argv[])
                         fprintf(stderr, "cannot open /dev/null\n");
                         log_error("cannot open /dev/null\n");
                 }
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         if (systemd_fds(udev, &fd_ctrl, &fd_netlink) >= 0) {
                 /* get control and netlink socket from systemd */
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
                 udev_ctrl = udev_ctrl_new_from_fd(udev, fd_ctrl);
                 if (udev_ctrl == NULL) {
                         log_error("error taking over udev control socket");
@@ -1204,6 +1223,7 @@ int main(int argc, char *argv[])
                         udev_cgroup = NULL;
         } else {
                 /* open control and netlink socket */
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
                 udev_ctrl = udev_ctrl_new(udev);
                 if (udev_ctrl == NULL) {
                         fprintf(stderr, "error initializing udev control socket");
@@ -1223,6 +1243,7 @@ int main(int argc, char *argv[])
                 fd_netlink = udev_monitor_get_fd(monitor);
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         if (udev_monitor_enable_receiving(monitor) < 0) {
                 fprintf(stderr, "error binding netlink socket\n");
                 log_error("error binding netlink socket\n");
@@ -1230,6 +1251,7 @@ int main(int argc, char *argv[])
                 goto exit;
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         if (udev_ctrl_enable_receiving(udev_ctrl) < 0) {
                 fprintf(stderr, "error binding udev control socket\n");
                 log_error("error binding udev control socket\n");
@@ -1237,8 +1259,10 @@ int main(int argc, char *argv[])
                 goto exit;
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         udev_monitor_set_receive_buffer_size(monitor, 128*1024*1024);
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         /* create queue file before signalling 'ready', to make sure we block 'settle' */
         udev_queue_export = udev_queue_export_new(udev);
         if (udev_queue_export == NULL) {
@@ -1246,8 +1270,10 @@ int main(int argc, char *argv[])
                 goto exit;
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         if (daemonize) {
                 pid_t pid;
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
 
                 pid = fork();
                 switch (pid) {
@@ -1264,11 +1290,14 @@ int main(int argc, char *argv[])
 
                 setsid();
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
                 write_one_line_file("/proc/self/oom_score_adj", "-1000");
         } else {
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
                 sd_notify(1, "READY=1");
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         print_kmsg("starting version " VERSION "\n");
 
         if (!debug) {
@@ -1283,6 +1312,7 @@ int main(int argc, char *argv[])
                 }
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         fd_inotify = udev_watch_init(udev);
         if (fd_inotify < 0) {
                 fprintf(stderr, "error initializing inotify\n");
@@ -1292,6 +1322,7 @@ int main(int argc, char *argv[])
         }
         udev_watch_restore(udev);
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         /* block and listen to all signals on signalfd */
         sigfillset(&mask);
         sigprocmask(SIG_SETMASK, &mask, &sigmask_orig);
@@ -1303,6 +1334,7 @@ int main(int argc, char *argv[])
                 goto exit;
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         /* unnamed socket from workers to the main daemon */
         if (socketpair(AF_LOCAL, SOCK_DGRAM|SOCK_CLOEXEC, 0, worker_watch) < 0) {
                 fprintf(stderr, "error creating socketpair\n");
@@ -1320,10 +1352,12 @@ int main(int argc, char *argv[])
                 goto exit;
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         memset(&ep_ctrl, 0, sizeof(struct epoll_event));
         ep_ctrl.events = EPOLLIN;
         ep_ctrl.data.fd = fd_ctrl;
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         memset(&ep_inotify, 0, sizeof(struct epoll_event));
         ep_inotify.events = EPOLLIN;
         ep_inotify.data.fd = fd_inotify;
@@ -1345,6 +1379,7 @@ int main(int argc, char *argv[])
                 log_error("error creating epoll fd: %m\n");
                 goto exit;
         }
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         if (epoll_ctl(fd_ep, EPOLL_CTL_ADD, fd_ctrl, &ep_ctrl) < 0 ||
             epoll_ctl(fd_ep, EPOLL_CTL_ADD, fd_inotify, &ep_inotify) < 0 ||
             epoll_ctl(fd_ep, EPOLL_CTL_ADD, fd_signal, &ep_signal) < 0 ||
@@ -1354,6 +1389,7 @@ int main(int argc, char *argv[])
                 goto exit;
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         /* if needed, convert old database from earlier udev version */
         convert_db(udev);
 
@@ -1373,6 +1409,7 @@ int main(int argc, char *argv[])
         udev_list_node_init(&event_list);
         udev_list_node_init(&worker_list);
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         for (;;) {
                 static unsigned long long last_usec;
                 struct epoll_event ev[8];
@@ -1550,11 +1587,14 @@ int main(int argc, char *argv[])
                         ctrl_conn = handle_ctrl_msg(udev_ctrl);
         }
 
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         rc = EXIT_SUCCESS;
 exit:
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         udev_queue_export_cleanup(udev_queue_export);
         udev_ctrl_cleanup(udev_ctrl);
 exit_daemonize:
+printf("doliyu: %d, %s, %s\n", __LINE__, __FUNCTION__, __FILE__ );
         if (fd_ep >= 0)
                 close(fd_ep);
         worker_list_cleanup(udev);
-- 
1.7.2.3

